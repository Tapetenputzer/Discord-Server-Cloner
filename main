#!/usr/bin/env python3
# -*- coding: utf-8 -*-


import discord
import asyncio
import sys
from io import BytesIO
import aiohttp
from discord.errors import HTTPException

# --- 1. Intents fallback ---
try:
    intents = discord.Intents.default()
    intents.guilds = True
    intents.emojis = True
    intents.messages = True
    use_intents = True
    print("‚ÑπÔ∏è Using discord.Intents")
except AttributeError:
    intents = None
    use_intents = False
    print("‚ö†Ô∏è No discord.Intents support detected; using fallback")

# --- 2. Ask for token and guild IDs ---
TOKEN = input("Discord user token: ").strip()
try:
    SRC_GUILD_ID = int(input("Source server ID (right-click server ‚Üí Copy ID): ").strip())
    DST_GUILD_ID = int(input("Destination server ID (right-click server ‚Üí Copy ID): ").strip())
except ValueError:
    print("‚úñ Unable to parse server ID. Enable Developer Mode in Discord Settings ‚Üí Appearance ‚Üí Advanced.")
    sys.exit(1)

# --- 3. Ask which steps to skip ---
skip_cleanup  = input("Skip cleanup of destination? (y/n): ").strip().lower() == "y"
skip_assets   = input("Skip copying server metadata & assets? (y/n): ").strip().lower() == "y"
skip_roles    = input("Skip copying roles? (y/n): ").strip().lower() == "y"
skip_emojis   = input("Skip copying emojis? (y/n): ").strip().lower() == "y"
skip_stickers = input("Skip copying stickers? (y/n): ").strip().lower() == "y"
skip_channels = input("Skip copying categories & channels? (y/n): ").strip().lower() == "y"

# --- 4. Create client ---
if use_intents:
    client = discord.Client(intents=intents, self_bot=True)
else:
    client = discord.Client(self_bot=True)

async def section_pause():
    await asyncio.sleep(10.0)

@client.event
async def on_ready():
    print(f"‚úÖ Logged in as {client.user} (ID: {client.user.id})")
    src = client.get_guild(SRC_GUILD_ID)
    dst = client.get_guild(DST_GUILD_ID)
    if not src or not dst:
        print("‚úñ One or both guilds not found. Check IDs and permissions.")
        await client.close()
        return

    print(f"‚ÑπÔ∏è Cloning ¬´{src.name}¬ª ‚Üí ¬´{dst.name}¬ª‚Ä¶")

    async def pause(seconds: float = 1.0):
        await asyncio.sleep(seconds)

    # --- 0. Cleanup ---
    if not skip_cleanup:
        print("üóëÔ∏è Cleaning destination guild‚Ä¶")
        for ch in dst.channels:
            if isinstance(ch, (discord.TextChannel, discord.VoiceChannel)):
                try:
                    await ch.delete()
                    print(f"  ‚úîÔ∏è Deleted channel: {ch.name}")
                except Exception as e:
                    print(f"  ‚úñ Error deleting channel ¬´{ch.name}¬ª: {e}")
                await pause()
        for cat in dst.categories:
            try:
                await cat.delete()
                print(f"  ‚úîÔ∏è Deleted category: {cat.name}")
            except Exception as e:
                print(f"  ‚úñ Error deleting category ¬´{cat.name}¬ª: {e}")
            await pause()
        for role in sorted(dst.roles, key=lambda r: r.position, reverse=True):
            if role.is_default():
                continue
            try:
                await role.delete(reason="Cleanup before cloning")
                print(f"  ‚úîÔ∏è Deleted role: {role.name}")
            except Exception as e:
                print(f"  ‚úñ Error deleting role ¬´{role.name}¬ª: {e}")
            await pause()
        for emoji in dst.emojis:
            try:
                await emoji.delete()
                print(f"  ‚úîÔ∏è Deleted emoji: {emoji.name}")
            except Exception as e:
                print(f"  ‚úñ Error deleting emoji ¬´{emoji.name}¬ª: {e}")
            await pause()
        await section_pause()

    # --- 1. Copy server metadata & assets ---
    if not skip_assets:
        try:
            icon   = await src.icon.read()   if src.icon   else None
            banner = await src.banner.read() if src.banner else None
            splash = await src.splash.read() if getattr(src, "splash", None) else None
            await dst.edit(
                name=src.name,
                description=getattr(src, "description", None),
                icon=icon, banner=banner, splash=splash
            )
            print("‚úÖ Server metadata & assets copied")
        except Exception as e:
            print(f"‚úñ Error copying server assets: {e}")
        await pause()
        await section_pause()

    # --- 2. Copy roles with back-off ---
    new_roles = {}
    if not skip_roles:
        for role in sorted(src.roles, key=lambda r: r.position):
            if role.is_default():
                new_roles[role.id] = dst.default_role
                continue
            while True:
                try:
                    new = await dst.create_role(
                        name=role.name,
                        permissions=role.permissions,
                        colour=role.colour,
                        hoist=role.hoist,
                        mentionable=role.mentionable,
                        reason="Cloning roles"
                    )
                    await new.edit(position=role.position)
                    new_roles[role.id] = new
                    print(f"‚úÖ Created role: {role.name}")
                    break
                except HTTPException as e:
                    if e.status == 429:
                        retry = getattr(e, "retry_after", 60)
                        print(f"‚ö†Ô∏è Rate limited when creating role ¬´{role.name}¬ª, sleeping {retry:.1f}s‚Ä¶")
                        await asyncio.sleep(retry + 1)
                    else:
                        print(f"‚úñ Error creating role ¬´{role.name}¬ª: {e}")
                        break
            await pause(3.0)
        await section_pause()

    # --- 3. Copy emojis with back-off ---
    if not skip_emojis:
        for emoji in src.emojis:
            while True:
                try:
                    if hasattr(emoji, "read"):
                        img = await emoji.read()
                    else:
                        async with aiohttp.ClientSession() as sess:
                            async with sess.get(str(emoji.url)) as resp:
                                img = await resp.read()
                    await dst.create_custom_emoji(name=emoji.name, image=img)
                    print(f"‚úÖ Created emoji: {emoji.name}")
                    break
                except HTTPException as e:
                    if e.status == 429:
                        retry = getattr(e, "retry_after", 60)
                        print(f"‚ö†Ô∏è Rate limited when creating emoji ¬´{emoji.name}¬ª, sleeping {retry:.1f}s‚Ä¶")
                        await asyncio.sleep(retry + 1)
                    else:
                        print(f"‚úñ Error creating emoji ¬´{emoji.name}¬ª: {e}")
                        break
            await pause(5.0)
        await section_pause()

    # --- 4. Copy stickers ---
    if not skip_stickers:
        for sticker in src.stickers:
            try:
                data = await sticker.read()
                await dst.create_sticker(
                    name=sticker.name,
                    description=sticker.description or "",
                    tags=sticker.tags or sticker.name,
                    file=BytesIO(data),
                    reason="Cloning stickers"
                )
                print(f"‚úÖ Created sticker: {sticker.name}")
            except Exception as e:
                print(f"‚úñ Error creating sticker ¬´{sticker.name}¬ª: {e}")
            await pause()
        await section_pause()

    # --- 5. Copy categories & channels ---
    if not skip_channels:
        new_cats = {}
        for cat in sorted(src.categories, key=lambda c: c.position):
            ow = {}
            for target, perms in cat.overwrites.items():
                if isinstance(target, discord.Role) and target.id in new_roles:
                    ow[new_roles[target.id]] = perms
                elif isinstance(target, discord.Member):
                    m = dst.get_member(target.id)
                    if m:
                        ow[m] = perms
            try:
                new = await dst.create_category(name=cat.name, position=cat.position, overwrites=ow)
                new_cats[cat.id] = new
                print(f"‚úÖ Created category: {cat.name}")
            except Exception as e:
                print(f"‚úñ Error creating category ¬´{cat.name}¬ª: {e}")
            await pause()

        uncategorized = []
        for ch in sorted(src.channels, key=lambda c: c.position):
            if isinstance(ch, (discord.TextChannel, discord.VoiceChannel)):
                parent = new_cats.get(ch.category_id)
                ow = {}
                for target, perms in ch.overwrites.items():
                    if isinstance(target, discord.Role) and target.id in new_roles:
                        ow[new_roles[target.id]] = perms
                    elif isinstance(target, discord.Member):
                        m = dst.get_member(target.id)
                        if m:
                            ow[m] = perms
                kwargs = {"name": ch.name, "position": ch.position, "overwrites": ow}
                if isinstance(ch, discord.TextChannel):
                    kwargs.update({"topic": ch.topic, "nsfw": ch.nsfw, "slowmode_delay": ch.slowmode_delay})
                else:
                    kwargs.update({"bitrate": ch.bitrate, "user_limit": ch.user_limit})
                try:
                    if parent:
                        if isinstance(ch, discord.TextChannel):
                            await dst.create_text_channel(category=parent, **kwargs)
                        else:
                            await dst.create_voice_channel(category=parent, **kwargs)
                    else:
                        uncategorized.append((ch, kwargs))
                    print(f"‚ÑπÔ∏è Prepared channel: {ch.name}")
                except Exception as e:
                    print(f"‚úñ Error creating channel ¬´{ch.name}¬ª: {e}")
                await pause()

        for ch, kwargs in uncategorized:
            try:
                if isinstance(ch, discord.TextChannel):
                    await dst.create_text_channel(**kwargs)
                else:
                    await dst.create_voice_channel(**kwargs)
                print(f"‚úÖ Created top-level channel: {ch.name}")
            except Exception as e:
                print(f"‚úñ Error creating top-level channel ¬´{ch.name}¬ª: {e}")
            await pause()

        await section_pause()

    print("üèÅ Cloning process complete!")
    await client.close()

if __name__ == "__main__":
    client.run(TOKEN)
